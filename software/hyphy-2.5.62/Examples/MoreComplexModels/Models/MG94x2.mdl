/* define the standard genetic code *//* AAA,AAC,AAG....TTA,TTC,TTG,TTT - 64 all in all*/_Genetic_Code = {					 {14,13,14,13,7,7,7,7,19, 5,19, 5,2,2,3,2,					  12,11,12,11,6,6,6,6,19,19,19,19,1,1,1,1,					  16,15,16,15,8,8,8,8,20,20,20,20,4,4,4,4,					  10,9, 10,9, 5,5,5,5,10,17,18,17,1,0,1,0}				};/*  	here's how codes translate to aminoacids 	 	0 == Phe 	1 == Leu 	2 == Ile 	3 == Met 	4 == Val 	5 == Ser 	6 == Pro 	7 == Thr 	8 == Ala 	9 == Tyr 	10 == Stop 	11 == His 	12 == Gln 	13 == Asn 	14 == Lys 	15 == Asp 	16 == Glu 	17 == Cys 	18 == Trp 	19 == Arg 	20 == Gly 	*/MG94_1 = {61,61}; MG94_2 = {61,61}; NICETY_LEVEL = 3;/* a flag to control Mac version responsiveness */		/* defines a sparse transition probabilities matrix  now we'll go through the matrix and assign the elements based on syn/non-syn status*/hshift = 0;for (h=0; h<64; h=h+1){	if ((h==56)||(h==50)||(h==48)) 	{		hshift = hshift+1;		continue; 	}	vshift = hshift;	for (v = h+1; v<64; v=v+1)	{		/*first check to see if the transition is one step*/		diff = v-h;		/*if the diff is less than 4 then there is a change in the 3rd slot only		  if the diff is divisible by 4 but not by 16 then there is a change in the 2nd slot only		  if the diff is divisible by 16  then there is a change in the 1st slot only		 */		if ((v==56)||(v==50)||(v==48)) 		{			vshift = vshift+1;			continue; 		}	  	if ((h$4==v$4)||((diff%4==0)&&(h$16==v$16))||(diff%16==0))	  	/* the transition is one-step and now we will determine whether it is syn or non-syn */	  	{	  		if (h$4==v$4)	  		{	  			transition = v%4;	  			transition2= h%4;	  		}	  		else	  		{	  			if(diff%16==0)	  			{	  				transition = v$16;	  				transition2= h$16;	  			}	  			else	  			{	  				transition = v%16$4;	  				transition2= h%16$4;	  			}	  		}	  		if (_Genetic_Code[0][h]==_Genetic_Code[0][v]) 	  		{	  			MG94_1[h-hshift][v-vshift] := synRate*observedFreq1__[transition__][0];	  			MG94_1[v-vshift][h-hshift] := synRate*observedFreq1__[transition2__][0];	  			MG94_2[h-hshift][v-vshift] := synRate*observedFreq2__[transition__][0];	  			MG94_2[v-vshift][h-hshift] := synRate*observedFreq2__[transition2__][0];		  	}	  		else	  		{		  		MG94_1[h-hshift][v-vshift] := nonSynRate*observedFreq1__[transition__][0];	  			MG94_1[v-vshift][h-hshift] := nonSynRate*observedFreq1__[transition2__][0];		  		MG94_2[h-hshift][v-vshift] := nonSynRate*observedFreq2__[transition__][0];	  			MG94_2[v-vshift][h-hshift] := nonSynRate*observedFreq2__[transition2__][0];  			}	  	}	  }}/* the following function compute equil. codon frequencies */function BuildCodonFrequencies (obsF){	PIStop = 1-obsF[3][0]*obsF[0][0]*obsF[2][0]-obsF[3][0]*obsF[2][0]*obsF[0][0]-obsF[3][0]*obsF[0][0]*obsF[0][0];	result = {61,1};	hshift = 0;	for (h=0; h<64; h=h+1)	{		if ((h==56)||(h==50)||(h==48)) 		{			hshift = hshift+1;			continue; 		}		first = h$16;		second = h%16$4;		third = h%4;		result[h-hshift][0]=obsF[first][0]*obsF[second][0]*obsF[third][0]/PIStop;	}	return result;}	